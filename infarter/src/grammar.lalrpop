use crate::asterix::*;
use std::str::FromStr;

grammar;


//match {
//    r"'.*" => {}, // comment
//    _
//}

pub Prog: Block = {
    Block
}

Block: Block = {
    <mut b:Block> <s:Stmt> => {b.push(s); b},
    Stmt => vec![<>],
}

Stmt: Stmt = {
    // variable assignement
    <id:Ident> "=" <e:Expr> "." =>
        Stmt::Assign(id.to_string(), e),
    // "operation on" assignements
    <id:Ident> <op:r"[+\-*/&|]{2}"> <ex:Expr> "." =>
        Stmt::OperOn(id.to_string(), BinOpcode::from_str(&op[0..1]), ex),
    // if else
    "(" <cond:Expr> ")" "=>" <b:Block>  <e:("(" ")" "=>" <Block>)?>
        "(" ")" "." =>
        Stmt::IfStmt(cond, b, e),
    // while loop
    "@" "(" <cond:Expr> ")" <b:Block> "@" "." =>
        Stmt::LoopIf(cond, b),
    // break
    "@" "(" ")" "." => Stmt::BreakL,
    // return
    "##" <Expr> "." => Stmt::Return(<>),
    // procedure declaration
    "!" <name:Ident> "!" <pars:(<Type> <Ident> ",")*> "!"
    <body:Block> "!" "." =>
        Stmt::PcDecl(Proc::new(&name, &pars, &body)),
    // "return;" exit proc
    "!!" "." => Stmt::PcExit,
    // procedure call
    <name:Ident> "!" <args:(<Expr> ",")*> "!" "."
        => Stmt::PcCall(name, args),
}

Expr: Expr = {
    <AddExpr>,
    <BoolExpr>,
}

BoolExpr: Expr = {
    <l:BoolExpr> <o:r"[&|]"> <r:AtomExpr> =>
        Expr::BinOp(Box::new(l), BinOpcode::from_str(o), Box::new(r)),
    <l:BoolExpr> <o:r"[&|]"> <r:BoolCmp> =>
        Expr::BinOp(Box::new(l), BinOpcode::from_str(o), Box::new(r)),
    <l:AtomExpr> <o:r"[&|]"> <r:AtomExpr> =>
        Expr::BinOp(Box::new(l), BinOpcode::from_str(o), Box::new(r)),
    <BoolCmp>,
}

BoolCmp: Expr = {
    <l:AddExpr> <o:r"(==|/=|<|>|<=|>=)"> <r:AddExpr> =>
        Expr::BinOp(Box::new(l), BinOpcode::from_str(o), Box::new(r)),
}

AddExpr: Expr = { // FIXME: dunno y [+-] didnt work
    <l:AddExpr> <o:r"[+\-]"> <r:MulExpr> => Expr::BinOp(
        Box::new(l), BinOpcode::from_str(o), Box::new(r)),
    MulExpr,
}

MulExpr: Expr = {
    <l:MulExpr> <o:r"[*/]"> <r:Term> => Expr::BinOp(
        Box::new(l), BinOpcode::from_str(o), Box::new(r)),
    Term,
}

Term: Expr = {
    AtomExpr,
    "(" "-" <t:Term> ")"  => Expr::UniOp(Box::new(t), UniOpcode::Sub),
    <t:PrimType> <e:AtomExpr> => Expr::Tcast(t, Box::new(e)),
};

AtomExpr: Expr = {
    Const => Expr::Const(<>),
    Ident => Expr::Ident(<>.to_string()),
    "(" <Expr> ")",
    // anonymous function
    <rett:Type> "#" "{" <pars:(<Type> <Ident> ",")*> "}"
        <body:Block> "#" "." =>
            Expr::Fdefn(Func::new(&pars, &body, &rett)),
    // function call
    <call:AtomExpr> "#" "{" <args:(<Expr> ",")*> "}" =>
        Expr::Fcall(Box::new(call), args),
    // explicit array
//    "{" <arr:(<Expr> ",")*> "}" => Box::new(Expr::Const(Val::B(false))),
}


Type: Type = {
    // funcs
    <r:Type> "#" "{" <a:(<Type> ",")*> "}" => Type::F(Box::new(r), a),
    // arrays
    "{" <Type> "}" => Type::A(Box::new(<>)),
    // BCNZR
    PrimType,
}

PrimType: Type = {
    r"[BCNZR]%" => Type::from_str(<>.get(0..1).unwrap()),
}

Ident: String = {
//    <i:ArrAccess> "_" AtomExpr => i,
    r"[A-Za-z][A-Za-z0-9]*" => <>.into(),
}

Const: Val = {
    "T" => Val::B(true),
    "F" => Val::B(false),
    r"[0-9]+"         => Val::N(u32::from_str(<>).unwrap()),
    r"[0-9]+\.[0-9]+" => Val::R(f32::from_str(<>).unwrap()),
    r#"C%".""# => Val::from_str_to_c(<>),
}
