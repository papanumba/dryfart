use crate::asterix::*;
use crate::twalker::*;
use std::str::FromStr;

grammar;


pub Prog: Block = {
    Block
}

Block: Block = {
    <mut b:Block> <s:Stmt> => {b.push(s); b},
    Stmt => vec![<>],
}

Stmt: Stmt = {
    // variable assignement
    <id:Ident> "=" <e:Expr> "." =>
        Stmt::Assign(id.to_string(), e),
    // "operation on" assignements
    <id:Ident> <op:r"[+\-*/&|]{2}"> <ex:Expr> "." =>
        Stmt::OperOn(id.to_string(), BinOpcode::from_str(&op[0..1]), ex),
    // if else
    "(" <cond:Expr> ")" "=>" <b:Block>  <e:("(" ")" "=>" <Block>)?>
        "(" ")" "." =>
        Stmt::IfStmt(cond, b, e),
    // while loop
    "@" "(" <cond:Expr> ")" <b:Block> "@" "." =>
        Stmt::LoopIf(cond, b),
    // break
    "@" "(" ")" "." => Stmt::BreakL,
    // return
    "##" <Expr> "." => Stmt::Return(<>),
    // procedure declaration
    "!" <name:Ident> "!" <pars:(<Type> <Ident> ",")*> "!"
    <body:Block> "!" "." =>
        Stmt::PcDecl(Proc::new(&name, &pars, &body)),
    // "return;" exit proc
    "!!" "." => Stmt::PcExit,
    // procedure call
    <name:Ident> "!" <args:(<Expr> ",")*> "."
        => Stmt::PcCall(name, args),
}

Expr: Expr = {
    OrExpr,
}

// þis one is þe highest level Bool Expr
OrExpr: Expr = {
    <l:OrExpr> "|" <r:AndExpr> =>
        Expr::BinOp(Box::new(l), BinOpcode::Or, Box::new(r)),
    AndExpr,
}

AndExpr: Expr = {
    <l:AndExpr> "&" <r:AndTerm> =>
        Expr::BinOp(Box::new(l), BinOpcode::And, Box::new(r)),
    AndTerm,
}

AndTerm: Expr = {
    AddExpr,
    NegExpr,
    // comparison
    <l:AddExpr> <o:r"(==|~=|<|>|<=|>=)"> <r:AddExpr> =>
        Expr::BinOp(Box::new(l), BinOpcode::from_str(o), Box::new(r)),
}

NegExpr: Expr = {
    "~" <AtomExpr> => Expr::UniOp(Box::new(<>), UniOpcode::Neg),
    "~" <NegExpr>  => Expr::UniOp(Box::new(<>), UniOpcode::Neg),
}

AddExpr: Expr = {
    <l:AddExpr> <o:"+"> <r:MulExpr> => Expr::BinOp(
        Box::new(l), BinOpcode::Add, Box::new(r)),
    <l:AddExpr> <o:"-"> <r:MulExpr> => Expr::BinOp(
        Box::new(l), BinOpcode::Sub, Box::new(r)),
    AddTerm,
}

AddTerm: Expr = {
    "-" <t:MulExpr>  => Expr::UniOp(Box::new(t), UniOpcode::Sub),
    MulExpr,
}

MulExpr: Expr = {
    <l:MulExpr> <o:"*"> <r:MulTerm> => Expr::BinOp(
        Box::new(l), BinOpcode::Mul, Box::new(r)),
    <l:MulExpr> <o:"/"> <r:MulTerm> => Expr::BinOp(
        Box::new(l), BinOpcode::Div, Box::new(r)),
    MulTerm,
}

MulTerm: Expr = {
    "/" <MulTerm> => Expr::UniOp(Box::new(<>), UniOpcode::Inv),
    AtomExpr,
}

AtomExpr: Expr = {
    Const => Expr::Const(<>),
    AnonFn,
    Idxable,
    // type cast of AtomExpr,
    // non function type, since functions cannot be casted
    <t:NonFnType> <e:AtomExpr> => Expr::Tcast(t, Box::new(e)),
    // explicit array
//    "{" <arr:(<Expr> ",")*> "}" => Box::new(Expr::Const(Val::B(false))),
}

Idxable: Expr = {
    Ident => Expr::Ident(<>.to_string()),
    "(" <Expr> ")",
    "{" <a:(<Expr> ",")*> "}" => Expr::Array(a),
    FnCall,
    // ArrayElement access
    <a:Idxable> "_" <i:Index> => Expr::ArrEl(Box::new(a), Box::new(i)),
}

Index: Expr = {
    Const => Expr::Const(<>),
    Ident => Expr::Ident(<>.to_string()),
    "(" <Expr> ")",
    FnCall,
}

// in order to get precedance of a_f#{} == a_(f#{}),
// to call a function from an array acces, one must (a_i)#{}
Callable: Expr = {
    Ident => Expr::Ident(<> .to_string()),
    "@"   => Expr::Ident("@".to_string()),
    "(" <Expr> ")",
    AnonFn,
    FnCall,
}

// anonymous function
AnonFn: Expr = {
    <rett:Type> "#" "{" <pars:(<Type> <Ident> ",")*> "}"
        <body:Block> "#" "." =>
            Expr::Fdefn(Func::new(&pars, &body, &rett)),
}

// function call
FnCall: Expr = {
    <call:Callable> "#" "{" <args:(<Expr> ",")*> "}" =>
        Expr::Fcall(Box::new(call), args),
}

Type: Type = {
    // funcs
    <r:Type> "#" "{" <a:(<Type> ",")*> "}" => Type::F(Box::new(r), a),
    // arrays
    ArrType,
    // BCNZR
    PrimType,
}

NonFnType: Type = {
    ArrType,
    PrimType,
}

ArrType: Type = {
    // ND array {{{R%}}}
    "{" <ArrType>  "}" => Type::A(Box::new(<>)),
    // 1D array   {R%}
    "{" <PrimType> "}" => Type::A(Box::new(<>)),
}

PrimType: Type = {
    r"[BCNZR]%" => Type::from_str(<>.get(0..1).unwrap()),
}

Ident: String = {
//    <i:ArrAccess> "_" AtomExpr => i,
    r"[A-Za-z][A-Za-z0-9]*" => <>.into(),
}

Const: Val = {
    "T" => Val::B(true),
    "F" => Val::B(false),
    r"[0-9]+"         => Val::N(u32::from_str(<>).unwrap()),
    r"[0-9]+\.[0-9]+" => Val::R(f32::from_str(<>).unwrap()),
    r#"C%".""# => Val::from_str_to_c(<>),
    r#""[^"]+""# => Val::A(Array::from_str(<>)),
}
