use crate::asterix::*;
use std::str::FromStr;

grammar;


//match {
//    r"'.*" => {}, // comment
//    _
//}

pub Prog: Block = {
    Block
};

Block: Block = {
    <mut b:Block> <s:Stmt> => {b.push(s); b},
    Stmt => vec![<>],
};

Stmt: Stmt = {
    // variable declaration
    <ty:PrimType> <id:Ident> "." =>
        Stmt::Declar(id.to_string(), ty),
    // variable assignation
    <id:Ident> "=" <e:Expr> "." =>
        Stmt::Assign(id.to_string(), *e),
    // simple if
    "[" <cond:Expr> "]" "=>" <b:Block> "[" "]" "." =>
        Stmt::IfStmt(*cond, b, None),
    // if else
    "[" <cond:Expr> "]" "=>" <b:Block>  "[" "]" "=>" <e:Block> "[" "]" "." =>
        Stmt::IfStmt(*cond, b, Some(e)),
    // while loop
    "L" "[" <cond:Expr> "]" <b:Block> "L" "." =>
        Stmt::LoopIf(*cond, b),
    // break
    "L" "[" "]" "." => Stmt::BreakL,
    // function declaration
    "#" <name:Ident> <rett:PrimType> "#" <pars:(<PrimType> <Ident> ",")*> "#"
    <body:Block> "#" "." =>
        Stmt::FnDecl(Func::new(&name, &pars, &body, &rett)),
    // return
    "#" <Expr> "." => Stmt::Return(*<>),
    // procedure declaration
    "!" <name:Ident> "!" <pars:(<PrimType> <Ident> ",")*> "!"
    <body:Block> "!" "." =>
        Stmt::PcDecl(Proc::new(&name, &pars, &body)),
    // "return;" exit proc
    "!!" "." => Stmt::PcExit,
    // procedure call
    <name:Ident> "!" <args:(<Expr> ",")*> "!" "."
        => Stmt::PcCall(name, args),
};

Expr: Box<Expr> = {
    <AddExpr>,
    <BoolExpr>,
    // function call
    <name:Ident> "#" <args:(<Expr> ",")*> "#" =>
        Box::new(Expr::Funcc(name, args)),
}

BoolExpr: Box<Expr> = {
    <l:BoolExpr> <o:r"[&|]"> <r:AtomExpr> =>
        Box::new(Expr::BinOp(l, BinOpcode::from_str(o), r)),
    <l:BoolExpr> <o:r"[&|]"> <r:BoolCmp> =>
        Box::new(Expr::BinOp(l, BinOpcode::from_str(o), r)),
    <l:AtomExpr> <o:r"[&|]"> <r:AtomExpr> =>
        Box::new(Expr::BinOp(l, BinOpcode::from_str(o), r)),
    <BoolCmp>,
}

BoolCmp: Box<Expr> = {
    <l:AddExpr> <o:r"(==|/=|<|>|<=|>=)"> <r:AddExpr> =>
        Box::new(Expr::BinOp(l, BinOpcode::from_str(o), r)),
}

AddExpr: Box<Expr> = { // FIXME: dunno y [+-] didnt work
    <l:AddExpr> <o:"+"> <r:MulExpr> => Box::new(Expr::BinOp(
        l, BinOpcode::from_str(o), r)),
    <l:AddExpr> <o:"-"> <r:MulExpr> => Box::new(Expr::BinOp(
        l, BinOpcode::from_str(o), r)),
    MulExpr,
};

MulExpr: Box<Expr> = {
    <l:MulExpr> <o:r"[*/]"> <r:Term> => Box::new(Expr::BinOp(
        l, BinOpcode::from_str(o), r)),
    Term,
};

Term: Box<Expr> = {
    AtomExpr,
    "(" "-" <t:Term> ")"  => Box::new(Expr::UniOp(
        t, UniOpcode::Sub)),
};

AtomExpr: Box<Expr> = {
    Const             => Box::new(Expr::Const(<>)),
    Ident             => Box::new(Expr::Ident(<>.to_string())),
    PrimType AtomExpr => Box::new(Expr::Tcast(<>)),
    "(" <Expr> ")",
}

PrimType: Type = {
    r"[BCNZR]%" => Type::from_str(<>.get(0..1).unwrap()),
}

Ident: String = {
    r"[A-Za-z]\w*" => <>.into()
}

Const: Val = {
    "T" => Val::B(true),
    "F" => Val::B(false),
    r"[0-9]+"         => Val::N(u32::from_str(<>).unwrap()),
    r"[0-9]+\.[0-9]+" => Val::R(f32::from_str(<>).unwrap()),
};
